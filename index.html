<html>
<head>
	<title>PGRF3 projekt</title>
	<script src="src/three.js"></script>
	<script src="src/libs/THREEx.KeyboardState.js"></script>
	<script src="src/libs/THREEx.FullScreen.js"></script>
	<script src="src/libs/THREEx.WindowResize.js"></script>
	<script src="src/libs/Stats.js"></script>
	<script src="src/libs/OrbitControls.js"></script>
	<script src="src/libs/Detector.js"></script>
	<script src="src/libs/DAT.GUI.js"></script>
	<style type="text/css">
		body{
			margin: 0;
		}
		canvas{
			width: 100%;
			height: 100%;
		}
	</style>
	<script id="vertexShader" type="x-shader/x-vertex">
		
		varying vec2 vUv;
		varying vec3 vPosition;
		varying vec3 vNormal;
		varying vec3 vTest;

		uniform vec3 vLight;
		
		const float PI = 3.14159265359;


		vec3 paramPos(vec3 inPos){
			float s = inPos.x * 2.0 - 1.0;
			float t = inPos.y * 2.0 - 1.0;
			return vec3(s, t, s * s - t * t);
		}

		vec3 torus(vec3 inPos){
							//
			float t = sqrt(((inPos.x*inPos.x + inPos.y*inPos.y)*cos(PI*2.0)*cos(PI*2.0))/sin(PI*2.0)*sin(PI*2.0));
			//vTest = t;
			t = min(1.0, t);
			// float y = t * sin(pi*2.0);
			// float x = t * cos(pi*2.0);
			//vTest = t;
			return vec3(inPos.x, inPos.y, t);
		}

		vec3 cylinder(vec3 inPos){
			float length = 2.0;
			float y = inPos.y;
			float r = length/(2.0 * PI);
			
			float z = cos(y/r) * r;
			y = sin(y/r) * r;

			return vec3(inPos.x, y, z);
		}

		void main() 
		{ 
		    vUv = uv;
			vPosition = cylinder(position);
		    gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition,1.0);
		}
		</script>

		<!-- fragment shader a.k.a. pixel shader -->
		<script id="fragmentShader" type="x-shader/x-vertex"> 
		
		varying vec2 vUv;
		varying vec3 vPosition;
		varying vec3 vNormal;
		varying vec3 vTest;

		uniform vec3 vLight;
		uniform vec4 vLightColor;
		uniform sampler2D texture1;
		uniform sampler2D normalTexture;
		uniform vec2 resolution;

		vec3 paramNormal(vec3 inPos){
			vec3 tx = vec3(2.0, 0.0, 8.0 * inPos.x);
			vec3 ty = vec3(0.0, 2.0, -8.0 * inPos.y);
			return cross(tx, ty);
		}

		void main() 
		{
			vec3 light = normalize(vLight);
			vec3 position = paramNormal(vPosition);
			vec3 normal = paramNormal(vNormal);

			vec3 lightVec = light - position; 

			float diff = dot(normalize(vNormal), normalize(vLight));
			diff = max(0.1, diff);

			vec3 specColor = vec3(1.0, 1.0, 1.0);
			float lambertian = max(dot(vLight, vNormal), 0.0);
			float specular = 0.0;
			if(lambertian > 0.0){
				float specAngle = max(dot(reflect(-vLight, vNormal), normalize(vPosition)), 0.0);
				specular = pow(specAngle, 4.0);
			}

			vec4 rTexture = texture2D(texture1, vUv);
			vec3 rLight = lambertian + specular * specColor;

			rTexture.xyz += rLight;

			//normal mapping

			vec4 diffuseColor = texture2D(texture1, vUv);

			vec4 nTexture = texture2D(normalTexture, vUv);
			vec3 nColor = nTexture.rgb * 2.0 - 1.0;

			vec3 vLightDir = vec3(vLight.xy - (gl_FragCoord.xy / resolution.xy), vLight.z);

			vLightDir.x *= resolution.x / resolution.y;

			float D = length(vLightDir);

			vec3 N = normalize(nColor);
			vec3 L = normalize(vLightDir);

			vec3 diffuse = vLightColor.rgb * max(dot(N, L), 0.0);

			vec3 ambient = vec3(1.0, 1.0, 1.0) * (0.8);

			vec3 intensity = ambient + diffuse;
			vec3 finalColor = diffuse.rgb * intensity;

		    gl_FragColor = vec4(vPosition, 0.5);
		}  
		</script>
</head>
<body>
</body>
	<script type="text/javascript">

		var controls;
		var t = THREE;

		var scene = new t.Scene();
		var camera = new t.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		var renderer = new t.WebGLRenderer();

		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		controls = new t.OrbitControls(camera, renderer.domElement);

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.bottom = '0px';
		stats.domElement.style.zIndex = 100;
		document.body.appendChild(stats.domElement);

		camera.position.z = 2;
		camera.position.x = 2;
		camera.position.y = 2;

		//GUI START
		var gui = new dat.GUI();

		var guiParameters = {
			x: 0
		};

		var coordinatesFolder = gui.addFolder("Coordinates");
		coordinatesFolder.add({x: 0}, 'x');
		coordinatesFolder.add({y: 0}, 'y');
		coordinatesFolder.add({z: 0}, 'z');
		coordinatesFolder.open();
		var functionFolder = gui.addFolder("Function");
		functionFolder.add({func: 'sothers'}, 'func');
		functionFolder.open();

		var cubeColor = gui.addColor({color: "#ff0000"}, 'color');
		cubeColor.onChange(function(value){
			console.log('change')
		});

		gui.open();

		//GUI END


		var light = new t.PointLight(0xffffff);
		light.position.set(0, 5, 0);
		scene.add(light);

		var geometry = new t.PlaneGeometry(2, 2, 20, 20);

		var texture = new t.ImageUtils.loadTexture("img/textures/rock.jpg");
		texture.wrapS = textureWrapT = t.RepeatWrapping;

		var normalTexture = new t.ImageUtils.loadTexture("img/textures/rock-normal.jpg")
		normalTexture.wrapS = textureWrapT = t.RepeatWrapping;

		var resolution = new t.Vector2(window.innerWidth, window.innerHeight);

		var uniforms1 = {
			"vLight": { type: 'v3', value: light.position},
			"vLightColor": {type: 'c', value: light.color},
			"texture1": { type: 't', value: texture},
			"normalTexture": {type: 't', value: normalTexture},
			"resolution": {type: 'v2', value: resolution }
		}

		var attributes = {
			"pi": {type: 'f', value: Math.PI},
			// "width": {type: 'f', value: geometry.width},
			// "triangleNumber": {type: 'f', value: geometry.widthSegments}
		};

		var material = new t.ShaderMaterial({
			uniforms: uniforms1,
			vertexShader: document.getElementById('vertexShader').textContent,
			fragmentShader: document.getElementById('fragmentShader').textContent,
			attributes: attributes,
			wireframe: true,
			side: t.DoubleSide,
			lights: false
		})
		var plane = new t.Mesh(geometry, material);

		var axisHelper = new t.AxisHelper(1);

		// plane.position.z = 2.5;
		// plane.position.y = 1.0;

		scene.add(axisHelper);
		scene.add(plane);
		scene.add(light);

		render();

		function render(){
			renderer.render(scene, camera);
			controls.update();
			stats.update();
			requestAnimationFrame(render);
		}

	</script>
</html>